package connectiondetailer

import (
	"encoding/xml"
	"errors"
	"fmt"
	"os/exec"

	"github.com/untangle/golang-shared/services/logger"
)

// Structs used to read in the XML generated by the conntrack command
type ConntrackConnectionDetails struct {
	XMLName xml.Name `xml:"conntrack"`
	Flows   []Flow   `xml:"flow"`
}

type Flow struct {
	XMLName xml.Name `xml:"flow"`
	Metas   []Meta   `xml:"meta"`
}

type Meta struct {
	XMLName   xml.Name `xml:"meta"`
	Direction string   `xml:"direction,attr"`

	// Direction is original or reply
	Layer3 ConntrackLayer3 `xml:"layer3"`
	Layer4 ConntrackLayer4 `xml:"layer4"`

	// Direction is independent
	Timeout int32 `xml:"timeout"`
	Mark    int32 `xml:"mark"`
	Use     int32 `xml:"use"`
	Id      int64 `xml:"id"`
}

type ConntrackLayer3 struct {
	XMLName   xml.Name `xml:"layer3"`
	Protonum  int32    `xml:"protonum,attr"`
	Protoname string   `xml:"protoname,attr"`
	Src       string   `xml:"src"`
	Dst       string   `xml:"dst"`
}

type ConntrackLayer4 struct {
	XMLName   xml.Name `xml:"layer4"`
	Protonum  int32    `xml:"protonum,attr"`
	Protoname string   `xml:"protoname,attr"`
	SPort     int32    `xml:"sport"`
	DPort     int32    `xml:"dport"`
}

type ConnTrackerDetails struct {
	connections    []*ConnectionInfo
	connectionsXml []byte
}

// Unit tests don't run as root, but the conntrack command requires it.
// To make this code testable, separate retrieving the connection XML
// from getting the ConnectionInfo list
// FetchSystemConnections() runs the conntrack command to retrieve its XML output
// Returns an error if something went wrong while running the command
func (connTrackerDetails *ConnTrackerDetails) FetchSystemConnections() error {
	var retError error

	// run conntrack command
	cmd := exec.Command("conntrack", "--dump", "--output", "extended", "--output", "xml")
	connTrackerDetails.connectionsXml, retError = cmd.CombinedOutput()

	return retError
}

// Sets connectionsXml, the XML file containing all system connections. Only used for testing
func (connTrackerDetails *ConnTrackerDetails) SetConnectionsXml(connectionXml []byte) {
	connTrackerDetails.connectionsXml = connectionXml
}

func (connTrackerDetails *ConnTrackerDetails) GetConnectionsXml() []byte {
	return connTrackerDetails.connectionsXml
}

// Gets the list of connections on the system. Make sure to run FetchSystemConnections
// before running GetConnectionList()
func (connTrackerDetails *ConnTrackerDetails) GetConnectionList() ([]*ConnectionInfo, error) {

	if connTrackerDetails.connectionsXml == nil {
		return nil, errors.New("ConnTrackerDetails requires that FetchSystemConnections is run before GetConnectionList()")
	}

	// Unmarshal XML output of conntrack command and get it into a useful data structure
	connTracker, err := parseConntrackXml(connTrackerDetails.connectionsXml)

	// Fail early if the XML provided by the conntrack command could not be read
	if err != nil {
		logger.Err("Could not Unmarshal XML output of the conntrack command")
		fmt.Println(err)
		return nil, err
	}

	// XML structure is pretty awkward, pull out it's data and put it in a more friendly data structure
	for _, flow := range connTracker.Flows {
		connectionInfo := new(ConnectionInfo)

		for _, meta := range flow.Metas {

			if meta.Direction == "independent" {
				connectionInfo.Independent = new(Independent)
				connectionInfo.Independent.Timeout = meta.Timeout
				connectionInfo.Independent.Mark = meta.Mark
				connectionInfo.Independent.Use = meta.Use
				connectionInfo.Independent.Id = meta.Id
			} else if meta.Direction == "reply" {
				connectionInfo.Reply = new(Connection)

				connectionInfo.Reply.Layer3 = new(Layer3)
				connectionInfo.Reply.Layer3.Protonum = meta.Layer3.Protonum
				connectionInfo.Reply.Layer3.Protoname = meta.Layer3.Protoname
				connectionInfo.Reply.Layer3.Src = meta.Layer3.Src
				connectionInfo.Reply.Layer3.Dst = meta.Layer3.Dst

				connectionInfo.Reply.Layer4 = new(Layer4)
				connectionInfo.Reply.Layer4.Protonum = meta.Layer4.Protonum
				connectionInfo.Reply.Layer4.Protoname = meta.Layer4.Protoname
				connectionInfo.Reply.Layer4.SPort = meta.Layer4.SPort
				connectionInfo.Reply.Layer4.DPort = meta.Layer4.DPort
			} else if meta.Direction == "original" {
				connectionInfo.Original = new(Connection)

				connectionInfo.Original.Layer3 = new(Layer3)
				connectionInfo.Original.Layer3.Protonum = meta.Layer3.Protonum
				connectionInfo.Original.Layer3.Protoname = meta.Layer3.Protoname
				connectionInfo.Original.Layer3.Src = meta.Layer3.Src
				connectionInfo.Original.Layer3.Dst = meta.Layer3.Dst

				connectionInfo.Original.Layer4 = new(Layer4)
				connectionInfo.Original.Layer4.Protonum = meta.Layer4.Protonum
				connectionInfo.Original.Layer4.Protoname = meta.Layer4.Protoname
				connectionInfo.Original.Layer4.SPort = meta.Layer4.SPort
				connectionInfo.Original.Layer4.DPort = meta.Layer4.DPort
			}
		}

		connTrackerDetails.connections = append(connTrackerDetails.connections, connectionInfo)
	}

	return connTrackerDetails.connections, nil
}

// Parses XML provided by the conntrackXml byte slice
func parseConntrackXml(conntrackXml []byte) (*ConntrackConnectionDetails, error) {
	var connTrackerDetails *ConntrackConnectionDetails
	err := xml.Unmarshal(conntrackXml, &connTrackerDetails)

	return connTrackerDetails, err
}
